from database_client import SupabaseClient
from datetime import datetime, timedelta
import uuid

class HistoryService:
    #Database operations for task history (Objective 3)
    
    def __init__(self):
        self.client = SupabaseClient.get_client()
    
    def record_task_completion(self, user_id, task_id, start_time, end_time, date_obj):
        #Insert task history record
        history_id = str(uuid.uuid4())
        
        try:
            response = self.client.table('TaskHistory').insert({
                'historyId': history_id,
                'userId': user_id,
                'taskId': task_id,
                'startTime': start_time.isoformat(),
                'endTime': end_time.isoformat(),
                'date': date_obj.isoformat(),
                'completed_at': datetime.now().isoformat()
            }).execute()
            
            return response.data is not None
        
        except Exception as e:
            print(f"Error recording history: {e}")
            return False
    
    def get_task_history(self, user_id, task_name=None, since_date=None, limit=50):
        """
        Retrieve task history (Objective 3a - stores min 50 entries)
        
        Args:
            user_id: User ID
            task_name: Optional task name filter
            since_date: Optional date filter (for 30-day or 90-day queries)
            limit: Maximum records to return
        """
        try:
            # Build query with JOIN to get task names
            query = self.client.table('TaskHistory').select(
                'historyId, userId, taskId, startTime, endTime, date, completed_at, Task(name)'
            ).eq('userId', user_id)
            
            # Apply date filter if provided (Objective 3b - 90 days)
            if since_date:
                query = query.gte('date', since_date.isoformat())
            
            # Apply task name filter if provided
            if task_name:
                query = query.eq('Task.name', task_name)
            
            # Order by date and time
            query = query.order('date', desc=True).order('startTime', desc=True)
            
            # Limit results
            query = query.limit(limit)
            
            response = query.execute()
            
            # Format results
            history = []
            for record in response.data:
                history.append({
                    'history_id': record['historyId'],
                    'task_id': record['taskId'],
                    'task_name': record['Task']['name'] if record.get('Task') else None,
                    'start_time': datetime.fromisoformat(record['startTime']).time(),
                    'end_time': datetime.fromisoformat(record['endTime']).time(),
                    'date': datetime.fromisoformat(record['date']).date(),
                    'completed_at': record['completed_at']
                })
            
            return history
        
        except Exception as e:
            print(f"Error retrieving history: {e}")
            return []
    
    def delete_old_history(self, user_id, days=90):
        """Delete history records older than specified days (Objective 3b)"""
        cutoff_date = datetime.now() - timedelta(days=days)
        
        try:
            response = self.client.table('TaskHistory').delete().eq('userId', user_id).lt('date', cutoff_date.isoformat()).execute()
            
            return response.data is not None
        
        except Exception as e:
            print(f"Error deleting old history: {e}")
            return False
    
    def get_most_common_start_time(self, user_id, task_name):
        """
        Get most frequent start time for a task (Objective 4 - prediction)
        Uses 30-day window as per design
        """
        thirty_days_ago = datetime.now() - timedelta(days=30)
        
        try:
            # Query with aggregation
            response = self.client.table('TaskHistory').select(
                'startTime'
            ).eq('userId', user_id).eq('Task.name', task_name).gte('date', thirty_days_ago.isoformat()).execute()
            
            if not response.data:
                return None
            
            # Count frequency manually (Supabase doesn't support GROUP BY in Python SDK easily)
            from collections import Counter
            start_times = [record['startTime'] for record in response.data]
            time_counter = Counter(start_times)
            
            if time_counter:
                most_common = time_counter.most_common(1)[0]
                return datetime.fromisoformat(most_common[0]).time()
            
            return None
        
        except Exception as e:
            print(f"Error getting common start time: {e}")
            return None
    
    def get_task_frequency(self, user_id):
        """Get frequency of each task (for Objective 5 - recommendations)"""
        try:
            response = self.client.table('TaskHistory').select(
                'Task(name)'
            ).eq('userId', user_id).execute()
            
            # Count task frequencies
            from collections import Counter
            task_names = [record['Task']['name'] for record in response.data if record.get('Task')]
            task_counter = Counter(task_names)
            
            return dict(task_counter)
        
        except Exception as e:
            print(f"Error getting task frequency: {e}")
            return {}