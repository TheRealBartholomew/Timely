from database_client import SupabaseClient
from core.models.schedule import Schedule
from datetime import datetime, date, time
import uuid

class ScheduleService:
    #Database operations for schedule
    
    def __init__(self):
        self.client = SupabaseClient.get_client()
    
    def create_schedule_entry(self, user_id, task_id, start_time, end_time, date_obj, is_regular=False):
        #Insert new schedule entry
        schedule_id = str(uuid.uuid4())
        
        try:
            response = self.client.table('Schedule').insert({
                'scheduleId': schedule_id,
                'userId': user_id,
                'taskId': task_id,
                'start_time': start_time.isoformat() if isinstance(start_time, time) else str(start_time),
                'end_time': end_time.isoformat() if isinstance(end_time, time) else str(end_time),
                'date': date_obj.isoformat() if isinstance(date_obj, date) else str(date_obj),
                'isRegularTask': is_regular
            }).execute()
            
            if response.data:
                return Schedule(
                    schedule_id=schedule_id,
                    user_id=user_id,
                    task_id=task_id,
                    start_time=start_time,
                    end_time=end_time,
                    date=date_obj,
                    is_regular_task=is_regular
                )
            return None
        
        except Exception as e:
            print(f"Error creating schedule entry: {e}")
            return None
    
    def check_conflicts(self, user_id, date_obj, start_time, end_time):
        
        #Check for scheduling conflicts (Objective 13)
        #Returns: (has_conflict: bool, conflicting_schedules: list)
        
        try:
            # Query schedules for the same date
            response = self.client.table('Schedule').select('*').eq('userId', user_id).eq('date', date_obj.isoformat()).execute()
            
            conflicts = []
            for data in response.data:
                scheduled_start = datetime.fromisoformat(data['start_time']).time()
                scheduled_end = datetime.fromisoformat(data['end_time']).time()
                
                # Check overlap: (start1 < end2) AND (start2 < end1)
                if (scheduled_start < end_time and start_time < scheduled_end):
                    conflicts.append(data)
            
            return len(conflicts) > 0, conflicts
        
        except Exception as e:
            print(f"Error checking conflicts: {e}")
            return False, []
    
    def get_schedule_for_date(self, user_id, date_obj):
        #Retrieve all scheduled tasks for a specific date
        try:
            response = self.client.table('Schedule').select('*').eq('userId', user_id).eq('date', date_obj.isoformat()).execute()
            
            schedules = []
            for data in response.data:
                schedule = Schedule(
                    schedule_id=data['scheduleId'],
                    user_id=data['userId'],
                    task_id=data['taskId'],
                    start_time=datetime.fromisoformat(data['start_time']).time(),
                    end_time=datetime.fromisoformat(data['end_time']).time(),
                    date=datetime.fromisoformat(data['date']).date(),
                    is_regular_task=data.get('isRegularTask', False)
                )
                schedules.append(schedule)
            
            return schedules
        
        except Exception as e:
            print(f"Error retrieving schedule: {e}")
            return []
    
    def update_schedule_time(self, schedule_id, user_id, new_start, new_end):
        #Update scheduled time slot
        try:
            response = self.client.table('Schedule').update({
                'start_time': new_start.isoformat(),
                'end_time': new_end.isoformat()
            }).eq('scheduleId', schedule_id).eq('userId', user_id).execute()
            
            return response.data is not None
        
        except Exception as e:
            print(f"Error updating schedule: {e}")
            return False
    
    def delete_schedule(self, schedule_id, user_id):
        #Remove scheduled task
        try:
            response = self.client.table('Schedule').delete().eq('scheduleId', schedule_id).eq('userId', user_id).execute()
            
            return response.data is not None
        
        except Exception as e:
            print(f"Error deleting schedule: {e}")
            return False